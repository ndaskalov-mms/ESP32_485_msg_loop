//
// check arm restrictions
// params: byte partIxd - partition number (ID) to be used as index in partitionDB
//			   int 	action	- bitmask, DISARM = 0, REGULAR_ARM, FORCE_ARM, INSTANT_ARM, STAY_ARM, see enum  ARM_METHODS_t
//	returns: ERR_OK(0) if no restrictions found, !0 if something prevents partition arming
//
int checkArmRestrctions(byte partIxd, int action) {

//
// arm partition 
// params: byte partIxd - partition number (ID) to be used as index in partitionDB
//			   int 	action	- bitmask, DISARM = 0, REGULAR_ARM, FORCE_ARM, INSTANT_ARM, STAY_ARM, see enum  ARM_METHODS_t
//
void armPartition(byte partIxd, int action)  {
   ErrWrite(ERR_DEBUG, "Arming/Disarming partition %d\n", partIxd);                
   switch (action) {
		case DISARM:
		case REGULAR_ARM:
		case FORCE_ARM:
		case INSTANT_ARM:
		case STAY_ARM:
			if(partitionDB[partIxd].status == action)
				return;
			partitionDB[partIxd].status = action;
			armTime = millis();
			reportArm(byte partIxd);
			break;
		default:
			ErrWrite(ERR_WARNING, "Request to arm/disarm invalid partition %d\n", partIxd);
			break;
		}
	// fix follows partitions RECURSIVELLY
	for(int i = 0; i < MAX_PARTITION, i++) {
		if(i == partIxd)
			continue;
		logger.printf("Checking partition %d if follows partition %d\n", partitionDB[i], partIxd);
		if(!partitionDB[i].follows[partIxd]))		// follows is array of MAX_PARTITION bytes, if byte of idx i is true, 
			continue;								// it means that this partition follows partition idx = i
		logger.printf("Follow partition %d to partition %d found\n", partitionDB[i], partIxd);
		armPartition(partitionDB[i], action); 		// call recursively
		}
}	